---
layout: site
title: queue-flow Tutorial
subtitle: "Let the queue <em>flow</em> through you, Skywalker."
---
``queue-flow`` is a library for Javascript source code organization built on the concepts of queues, flowcharts, and functional programming. This tutorial will introduce these concepts, explain how they are combined together to produce a useful whole, and then the API and syntax will be introduced over time while discussing various patterns in synchronous code and how they are replicated with ``queue-flow``.

# Concepts

## Queues

For those who don't speak British English (myself included), "queues" may not be high in your vocabulary. Fortunately, a queue in computer science is very much like the standard definition.

Think of a line in a supermarket. The first person in the line is the first to be served, the second person is the second, and so on. First In, First Out

![FIFO](/queue-flow/images/fifo.svg)

But when will your turn come up? If there is only one register in front of your line/queue, then you have to wait for every person in front of you to be served entirely. But if there are four registers, you will be served by whichever of the four registers finishes with their client when you are at the front of the line.

This can be translated directly to software queues. Items (clients) are queued up, and workers (registers) dequeue and process (serve) the items.

Queues can also lead into other queues, much like a factory floor for vehicles. In this situation, a piece of data is processed on by one worker, then passed into another queue to be worked on by the next, etc. In an ideal situation, there would be space for only one item in a queue, like the conveyor belt on the factory floor, as each step is broken into roughly equal amounts of processing time necessary, and all of the workers are kept equally busy.

Tasks that take a longer amount of time could be done in parallel by a few workers to get the average time to equal the time needed by the faster tasks, when trying to optimize, and if each item involved is independent of the next, as with grocery checkout or car-making, then this is a valid step to take.

Later on, if demand starts to exceed the throughput of this tuned queue, but the processing time of any one item is tolerable, performance can be increased by simply duplicating the tuned queue as many times as necessary for the demand.

Chained queues with processing broken across many small pieces like describe above allows for that sort of performance optimization with little change to the process (code) involved. It worked for Ford, it can work for your code, too!

## Flowcharts

But much software isn't doing the same things over and over, like a car factory. It has to adapt to what it's users want, and depending on what is needed, different things may be necessary to be done. Shoehorning that into a single, linear queue is only asking for trouble.

![Flowcharts!](http://www.edrawsoft.com/images/examples/makeflowchart.png)

Flowcharts are a basic, high-level descriptions of things to do, with simple sentences and questions denoting things to do and decide on. The actual process is an implementation detail. Imperative flow control is directly translatable from flow charts, with functions serving as the implementation detail. With classic functions and imperative flow control, though, only one part of the flow chart is in use at a time, and each use of the flow chart must wait for the prior use to complete.

Queues that solve a particular action or decision in a flowchart could just as easily be substituted in for functions, and at the end of each queue, the result could be pushed onto the next queue, which is either pre-determined (a linear flow), or decided upon based on some criteria about the data in question (a branch), but with queues, one piece of data could be half-way through the flowchart built through the queues while another piece is just starting and another is finishing. There could even be another piece working on the exact same step if there are multiple workers.

Everything said before about the advantages of queues can apply to a flowchart built via queues, a *queue flow*, and source code organization can be roughly the same as imperative-style code.

## Functional Programming

So, if everything is so awesome, why isn't the pattern being used all the time?

The answer to that is simple: queues require a bit more discipline than imperative code, because (good) queue processing is built on functional programming.

At its core, functional programming is simply programming using functions.

*Only* functions.

No ``for(var i = 0; i < array.length; i++) { /* Do something */ }``.

Instead ``array.forEach(function doSomething(value, index) { /* ... */ });``.

No ``if(this == that) { doThis() } else { doThat() }``.

Instead ``ifElse(function() { return this == that; }, doThis, doThat);``.

And ideally, no global references, and possibly no closures -- the only thing your function should affect is what it returns -- that's pure functional programming.

Now, Javascript is a multi-disciplined language, so nothing is stopping you from doing all of this, or doing this inside of your own functions when using *queue-flow*, and I see no problem with using a bit of imperative code where it makes sense, but in queues, it makes less sense than you expect.

What's the advantage of using functions everywhere? Simple. Anywhere you see a function provided or called, you can with a short bit of typing replace that part entirely with a different function. And all the places that use that function will get a performance boost or bug fix when you speed up or fix that function. DRY, Don't Repeat Yourself. But there's also another feature using functions everywhere helps -- composability. Generic functions that solve a problem can be combined with other functions to solve another problem, and these can be stacked on each other for greater and greater problems.

Now, this depends on your personal ability to keep things in your head, but many many functions built out of a small number of functions slowly accreted into large functions that solve your software problem are easier to rearrange, improve upon, and expand to handle new capabilities, because the scope of what the function does was kept as small as possible.

Queues stream data into their respective workers. The more workers you have in series, the more pieces of data can be operated on at the same time even without explicit parallelism. But then the actions of each worker are kept smaller and smaller. This is fine, though, because a particular worker that solves one small problem in one queue is more likely to be useful to another queue.

And I'm stopping and committing here for now because this Functional Programming section sucks and I need to think about how I want to explain this...

# The essense of *queue-flow*

## queues glued to functional programming glued to queues in a linear (or not) flow

## *queue-flow* syntax

# Patterns with *queue-flow*

## *map, reduce, filter, each, branch, exec...* What are they for?

## branching

## looping and recursion

## sorting and graph traversal

# What next?