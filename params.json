{"name":"queue-flow","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","body":"    npm install queue-flow\r\n\r\nFor browsers, just copy ``./lib/queue-flow.min.js`` (generated by [UglifyJS](https://github.com/mishoo/UglifyJS/))and include it in a ``<script>`` tag.\r\n\r\nFor developers, ``npm test`` to check your changes (using [nodeunit](https://github.com/caolan/nodeunit/)) haven't broken existing functionality. Literate programming documentation can be found inside of the ``/docs`` directory, generated by [docco](http://jashkenas.github.com/docco/).\r\n\r\n## Latency-reducing, async-capable functional programming using named (or not) queues\r\n\r\nYou'd very much like to use ECMAScript 5's nice functional programming concepts,\r\n\r\n```js\r\nconsole.log([1,2,3,4,5,6,7,8,9,10]\r\n\t.map(function(val) {\r\n\t\tconsole.log('map ' + val);\r\n\t\treturn val;\r\n\t})\r\n\t.reduce(function(prev, val) {\r\n\t\tconsole.log('reduce ' + val);\r\n\t\treturn val;\r\n\t}, 0)\r\n);\r\n```\r\n\r\nPrints:\r\n\r\n    map 1\r\n    map 2\r\n    map 3\r\n    map 4\r\n    map 5\r\n    map 6\r\n    map 7\r\n    map 8\r\n    map 9\r\n    map 10\r\n    reduce 1\r\n    reduce 2\r\n    reduce 3\r\n    reduce 4\r\n    reduce 5\r\n    reduce 6\r\n    reduce 7\r\n    reduce 8\r\n    reduce 9\r\n    reduce 10\r\n    10\r\n\r\nBut there are two significant issues:\r\n\r\n1. This is a blocking API, so no AJAX allowed, no Node.js libraries allowed.\r\n2. Each step in the process will only start its work *after* the previous step has completed *all* of the work it has to do, meaning significant latency, especially when the processing time of the callback is unpredictable.\r\n\r\nThese deficiencies mean the clean, easy-to-read-and-refactor functional style aren't practical in Javascript. The [async library](https://github.com/caolan/async) makes significant headway on this problem, but still feels more awkward.\r\n\r\n## Enter *queue-flow*\r\n\r\n```js\r\nvar q = require('queue-flow');\r\n\r\nq([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\r\n\t.map(function(val) {\r\n\t\tconsole.log('map ' + val);\r\n\t\treturn val;\r\n\t})\r\n\t.reduce(function(prev, val) {\r\n\t\tconsole.log('reduce ' + val;\r\n\t\treturn val;\r\n\t}, function(result) {\r\n\t\tconsole.log(result);\r\n\t}, 0);\r\n```\r\n\r\nPrints:\r\n\r\n    map 1\r\n    map 2\r\n    map 3\r\n    map 4\r\n    reduce 1\r\n    map 5\r\n    reduce 2\r\n    map 6\r\n    reduce 3\r\n    reduce 4\r\n    map 7\r\n    reduce 5\r\n    map 8\r\n    reduce 6\r\n    map 9\r\n    reduce 7\r\n    map 10\r\n    reduce 8\r\n    reduce 9\r\n    reduce 10\r\n    10\r\n\r\n**queue-flow** builds a series of input and output queues for work to traverse from functional concept to functional concept, with reduce-style functions (that compress all values into a single result) instead having a final callback fired when the queue processing is completed.\r\n\r\nMaking a callback an asynchronous one is as simple as added an extra argument for the callback passed to it at the end of the function definition.\r\n\r\n```js\r\nq([1, 2, 3])\r\n\t.map(function(val, callback) {\r\n\t\tcallback(val*2);\r\n\t})\r\n\t.toArray(function(result) {\r\n\t\tconsole.log(result); // Prints [2, 4, 6]\r\n\t});\r\n```\r\n\r\nIf you don't want to declare an arguments list and instead use the ``arguments`` object to get the values (perhaps using the ``exec`` queue-flow method and having a variable number of arguments each time) and it needs to be async (callback appended, but in a different position each time), then you mus mark the callback as an asynchronous one with the simple ``q.async`` method, like so:\r\n\r\n```js\r\nq([1, 2, 3])\r\n\t.map(q.async(function() {\r\n\t\targuments[1](arguments[0]*2);\r\n\t}))\r\n\t.toArray(function(result) {\r\n\t\tconsole.log(result); // Prints [2, 4, 6]\r\n\t});\r\n```\r\n\r\nQueues can also be named and accessed elsewhere:\r\n\r\n```js\r\nq([1, 2, 3]).as('namedQueue');\r\n\r\nq('namedQueue').toArray(function(result) {\r\n\tconsole.log(result); // [1, 2, 3]\r\n});\r\n```\r\n\r\nQueues that are provided a full array initially automatically close when the queue empties. Queues can also be named and provide no initial values, which can be ``.push()``ed later. These queues must either be told to ``.closeOnEmpty()`` or must be manually ``.close()``d.\r\n\r\n```js\r\nq('initiallyEmpty')\r\n\t.push(1, 2, 3)\r\n\t.closeOnEmpty()\r\n\t.toArray(console.log); // [1, 2, 3]\r\n\r\nq('alsoFirstEmpty')\r\n\t.push(4, 5, 6)\r\n\t.toArray(console.log);\r\n\r\nq('alsoFirstEmpty').close(); // [4, 5, 6]\r\n```\r\n\r\nThis behavior is used quite nicely by the ``.branch`` method, which is a new functional flow control mechanism for splitting your processing across different, easy-to-digest queue flows:\r\n\r\n```js\r\nq([1, 2, 'skip a few', 99, 100])\r\n\t.branch(function(value) {\r\n\t\tif(value == value + 0) { // is a number\r\n\t\t\treturn value > 50 ? 'big' : 'small';\r\n\t\t} else {\r\n\t\t\treturn 'invalid';\r\n\t\t}\r\n\t});\r\n\r\nq('big')\r\n\t.map(function(value) {\r\n\t\tconsole.log(value + \"? I can't count that high! Let's make it smaller.\");\r\n\t\treturn value - 50;\r\n\t})\r\n\t.each(function(value) {\r\n\t\tconsole.log(value + \" is a much better number, don'tcha think?\");\r\n\t});\r\n\r\nq('small')\r\n\t.each(function(value) {\r\n\t\tconsole.log('Ahh... ' + value + \". That's a nice number!\");\r\n\t});\r\n\r\nq('invalid')\r\n\t.each(function(value) {\r\n\t\tconsole.warn(value + \"? You can't do that!\");\r\n\t});\r\n```\r\n\r\nQueue flows may also be monitored by event handlers, which borrow the jQuery syntax and can also cancel all events except ``empty`` (which would be nonsensical, as it's only informative).\r\n\r\n```js\r\nq([1, 2, 3])\r\n\t.on('pull', function(value) {\r\n\t\tconsole.log(\"Someone's a'stealin' my number \" + value);\r\n\t\tconsole.log(\"I ain't lettin' ya!\");\r\n\t\treturn false;\r\n\t})\r\n\t.toArray(console.log); // Never fires\r\n```\r\n\r\nWhen requesting a queue, an optional second parameter may be provided to use a third-party constructor, which will be useful for things like queue-flows designed for Web Workers or Node Clusters, but none exist, yet. Developers of such a library should use the tests in the ``./test`` directory to verify proper behavior of their plugin.\r\n\r\n```js\r\nq([1, 2, 3], WebWorkerQueue); // Someday...\r\n```\r\n\r\n## API Reference\r\n\r\nqueue-flow consists of a helper function and its methods for initially constructing a queue-flow object, and the default queue-flow consructor and its methods (privileged and prototypal).\r\n\r\n### ``q`` Accessor/Constructor Helper\r\n\r\nThis is the only thing publicly exposed by the library.\r\n\r\n```js\r\nq([nameOrArray], [qType]) // returns: new Q([nameOrArray], [qType])\r\n```\r\n\r\n``nameOrArray`` is either a string or an Array object, or can be left undefined.\r\n\r\nWhen a string, the string is used as the queue's name, which is either found in the set of named queues or is constructed on the spot and added to the set.\r\n\r\nWhen an array, the array is used to populate the unnamed queue immediately, and the queue is set to automatically close itself when empty.\r\n\r\nWhen undefined, and unnamed queue is created with no values. This is the only unnamed queue that will not automatically close itself when empty.\r\n\r\n``qType`` is either a constructor function or left undefined. queue-flow does nothing to verify that the provided constructor function is valid, except checking that it is a ``Function`` object, so use this mechanism with care!\r\n\r\n### ``q.async`` (or ``q.cps``) Helper Method\r\n\r\nThis method flags a given function as one that should receive an asynchronous method list (with a callback) and the API will then expect the results be returned via the callback rather than immediately.\r\n\r\n```js\r\nq.async(func) // returns: modified func\r\n```\r\n\r\nAny ``Function`` object will succeed on this method, but it is up to the developer to make sure his arguments list matches the one specified for the queue processor his function is being given to.\r\n\r\n### ``q.isAsync`` Helper Method\r\n\r\nThis method performs the (fast-but-imperfect) guesswork on whether a provided method is asynchronous or not. First, it checks if the ``async`` property exists for the function, and then it checks if the argument length of the function matches the specified length an asynchronous function would have.\r\n\r\n```js\r\nq.isAsync(func, asyncArgLength) // returns: boolean\r\n```\r\n\r\n### ``q.ns`` Helper Method\r\n\r\nThis method takes no arguments, and returns a wholly-independent queue-flow namespace. Queue flows from one *cannot* interact with queue flows from another (without writing some bridge code manually). This is to allow methods to work with named queues that have generic, easy-to-follow names, like ``error`` or ``requests`` and not have to worry about collisions with the queue flows spawned by other functions that might want to use the same name.\r\n\r\n### ``q.tuple`` Helper Method\r\n\r\nThis method takes a Javascript object and converts it into an array of tuples (two value arrays). Each tuple is a set of ``[key, value]`` pairs from the original object. This is useful if you wish to operate on each item in the object independently of one another.\r\n\r\n```js\r\nq.tuple(obj) // returns: array of tuples [[key1, value1], [key2, value2], ... ]\r\n```\r\n\r\n### ``Q`` Constructor\r\n\r\n```js\r\nnew q.Q([nameOrArray], [qType])\r\n```\r\n\r\nConstructing the ``Q`` object directly is *not* recommended, because it is not aware of the \"named queue\" mechanism. It simply ignores any value that isn't an array and substitutes with an empty array, and any ``Q`` object created with a non-full array must be manually ``.close()``d. In all other respects it behaves identically to constructing the queue flow with ``q``.\r\n\r\n### ``new Q().on`` Privileged Method\r\n\r\n```js\r\nq('someQueue').on(event, callbackFunction); // returns Q instance\r\n```\r\n\r\nThere are 4 events in queue-flow: ``push``, ``pull``, ``close``, and ``empty``. All events except ``empty`` may be cancelled by returning ``false``. The method signatures of the callbacks for each event are as follows:\r\n\r\n```js\r\n{\r\n\tpush: function(value) {},\r\n\tpull: function(value) {},\r\n\tclose: function() {},\r\n\tempty: function() {}\r\n}\r\n```\r\n\r\nThe callbacks' ``this`` is bound to the ``Q`` instance they are called on, more than one callback may be registered for a given event, they will be run in the order they are registered, and execution of event handlers will cease the moment any callback returns false (even for ``empty``, but it won't cancel the event in any other way).\r\n\r\n### ``new Q().fire`` Privileged Method\r\n\r\n```js\r\nq('someQueue').fire(event, some, other, variables); // Returns true or false\r\n```\r\n\r\nThis is the mechanism by which events are fired, and meant primarily as a private method. It is exposed to allow the user to false-fire an event if they choose to do so (not recommeded), or for new prototypal methods to fire a new event invented for themselves (more understandable).\r\n\r\nThe first argument is a string to identify the event, and the remaining arguments are made the new arguments to each registered event handler.\r\n\r\n### ``new Q().clear`` Privileged Method\r\n\r\n```js\r\nq('someQueue').clear('empty'); // returns Q instance\r\n```\r\n\r\nThis method clears out all event handlers for a given event.\r\n\r\n### ``new Q().setHandler`` Privileged Method\r\n\r\n```js\r\nq('someQueue').setHandler(handlerCallback); // returns Q instance\r\n```\r\n\r\nThis method drains the queue and calls the given callback for each value. It is a very low-level queue processing function that is used internally by nearly all of the prototypal methods.\r\n\r\nThe ``handlerCallback`` signature is simply ``function(value, callback) { }`` where the ``callback`` takes no arguments and informs the queue to continue processing.\r\n\r\n### ``new Q().push`` Privileged Method\r\n\r\nThis method pushes new values onto the queue. Each argument is a separate queue value.\r\n\r\n### ``new Q().close`` Privileged Method\r\n\r\nThis method destroys the queue. If there is a registered mechanism for draining the queue, it waits until all remaining items in the queue have been drained, otherwise it destroys on the next run through the Javascript event loop.\r\n\r\n### ``Q.prototype.as`` Method\r\n\r\n```js\r\nq([1, 2, 3]).as(name); // returns Q instance\r\n```\r\n\r\nThis method take a string and registers the specific queue under that name. Queues may have more than one name.\r\n\r\n### ``Q.prototype.closeOnEmpty`` Method\r\n\r\n```js\r\nq('name').closeOnEmpty(); // returns Q instance\r\n```\r\n\r\nThis method registers an event handler for the ``empty`` event to close the queue. Mostly used internally but may have a few other use-cases.\r\n\r\n### ``Q.prototype.load`` Method\r\n\r\n```js\r\nq('name').load(array); // returns Q instance\r\n```\r\n\r\nThis method is syntactic sugar for loading an array of values for the queue on top of the ``push`` Privileged Method, since using ``.apply`` on ``push`` is awkward when the queue flow reference is a long name, and worse with an unnamed queue flow, which must be saved to a variable, first, otherwise.\r\n\r\n### ``Q.prototype.each`` Method\r\n\r\n```js\r\nq([1,2,3]).each(eachCallback); // returns a new Q instance\r\n```\r\n\r\nThis method performs an each operation, which can be seen as a specialization of map. The eachCallback is given a value from the queue one at a time, and the callback is expected to perform some sort of side-effect operation not affecting the queue flow in any way, as it simply creates a new queue and pushes the input values into the new output queue.\r\n\r\n### ``Q.prototype.map`` Method\r\n\r\n```js\r\nq([1,2,3]).map(mapCallback); // returns a new Q instance\r\n```\r\n\r\nThis method performs a map operation. Values from the first queue are pulled, manipulated by the given callback, and then pushed into a new, anonymous queue which is returned as a reference for the next method in the chain. If the upstream queue is closed, map will propagate that change to the queue it's been given.\r\n\r\nThere are two function signatures for the map callback:\r\n\r\n```js\r\n{\r\n\tsync: function(val) { return something; },\r\n\tasync: function(val, callback) { callback(something); }\r\n}\r\n```\r\n\r\n### ``Q.prototype.reduce`` Method\r\n\r\n```js\r\nq([1, 2, 3]).reduce(reduceCallback, finalCallback, initialCondition); // returns the original Q instance\r\n```\r\n\r\nThis method performs a reduce operation. Values from the queue are pulled, manipulated by the first callback which has been given the previous value (or initialCondition), and when the queue closes, the results are passed to the final callback.\r\n\r\nThere are two function signatures for the first reduce callback:\r\n\r\n```js\r\n{\r\n\tsync: function(prev, val) { return something; },\r\n\tasync: function(prev, val, callback) { callback(something); }\r\n}\r\n```\r\n\r\nThe second callback has just one signature:\r\n```js\r\nfunction(result) { /* Do whatever */ }\r\n```\r\n\r\n### ``Q.prototype.filter`` Method\r\n\r\n```js\r\nq([1, 2, 3]).filter(filterCallback); // returns a new Q instance\r\n```\r\n\r\nThis method performs a filter operation. Values from the queue are pulled and passed to the filter callback. If the callback returns true, the value is passed on to the new anonymous queue, otherwise it is discarded.\r\n\r\nThere are two function signatures for the filter callback:\r\n\r\n```js\r\n{\r\n\tsync: function(val) { return true || false; },\r\n\tasync: function(val, callback) { callback(true || false); }\r\n}\r\n```\r\n\r\n### ``Q.prototype.branch`` Method\r\n\r\n```js\r\nq([1, 2, 3]).branch(branchCallback); // returns the original Q instance\r\n```\r\n\r\nThis method performs the queue-flow-specific branch operation. Values from the queue are pulled and passed to the filter callback. The callback then returns the name of the queue the value should be inserted into.\r\n\r\nThere are two function signatures for the branch callback:\r\n\r\n```js\r\n{\r\n\tsync: function(val) { return 'queueName'; },\r\n\tasync: function(val, callback) { callback('queueName'); }\r\n}\r\n```\r\n\r\n### ``Q.prototype.every`` and ``Q.prototype.some`` Methods\r\n\r\nThese methods have the following signatures:\r\n\r\n```js\r\nq([1, 2, 3]).every(everyCallback, finalCallback); // returns original Q instance\r\nq([1, 2, 3]).some(someCallback, finalCallback); // returns original Q instance\r\n```\r\n\r\nFor both, the first callback, just like the first callback of the ``filter`` method, and must return a true or false. However, they are like ``reduce`` in that they return a singular value at the end. For ``every``, it passes ``true`` to the final callback *only if every* call to the first callback returns true, otherwise it short-circuits and returns false. For ``some`` is the opposite, it passes ``true`` to the final callback if it receives a single ``true`` from the first callback, otherwise it returns ``false`` after the entire array is parsed.\r\n\r\nThe first callback of both have the exact same signatures as the ``filter`` method's first callback.\r\n\r\n### ``Q.prototype.toArray`` Method\r\n\r\n```js\r\nq([1, 2, 3]).toArray(callback); // returns original Q instance\r\n```\r\n\r\nThis method drains the attached queue and constructs a \"normal\" array, which is then passed to the specified callback, which is the only argument. This callback has the following signature:\r\n\r\n```js\r\nfunction(array) { /* Do whatever */ }\r\n```\r\n\r\n### ``Q.prototype.flatten`` Method\r\n\r\n```js\r\nq([1, [2, [3]]]).flatten(depth); // returns new Q instance\r\n```\r\n\r\nThis method takes an input queue, and \"flattens\" out any nested arrays, passing along their values to a new queue in the order found. An optional ``depth`` value can be specified to determine how many layers of arrays should be flattened out. This method is heavily inspired by the underscore.js method of the same name.\r\n\r\n### ``Q.prototype.exec`` Method\r\n\r\n```js\r\nq([1, 2, 3]).exec(callback, onError, cbThis); // returns new Q instance\r\n```\r\n\r\nThis method is a variant on `map` designed to fit in well with the Node.js APIs (and other Node.js libraries). Each input value is passed into the provided callback, just like `map`, but if the value is an array, instead the arguments of the callback are populated by the array values (with a callback attached to the end if the callback is declared asynchronous).\r\n\r\nIf the provided callback is synchronous, it is assumed that whatever is returned is a valid result, and whatever is thrown is an error. If the callback is asynchronous, it is assumed that the first argument is passed to its own callback is an error value and the second argument is the correct result.\r\n\r\n`onError` is a \"magic\" variable that does one of 4 things depending on the type of value it is. If the variable is not defined (or is \"falsy\") then `exec` just ignores the bad result and continues on to the next one in the queue. If the variable is a `Function`, then it stops pulling values from the queue and calls the specified function. If it is a `string`, then it pushes the `error, value` combo into the named queue specified. If it is any other kind of \"truthy\" value, then `exec` stops execution right then and does nothing else.\r\n\r\n### ``Q.prototype.chain`` Method\r\n\r\n```js\r\nq([1, 2, 3]).chain(queueName); // returns original Q instance\r\n```\r\n\r\nThis method is a simple wrapper around ``branch`` that pushes the input values into the specified queue. Useful for chaining several sub-queues into one large queue (for legibility reasons).\r\n\r\n## License (MIT)\r\n\r\nCopyright (C) 2012 by David Ellis\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n","tagline":"Chainable logic built on named (or not) queues in Javascript"}