<!DOCTYPE html>

<html>
<head>
  <title>queue-flow.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>queue-flow.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>queue-flow Copyright (C) 2012-2013 by David Ellis</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> isAsync = require(<span class="string">'is-async'</span>);
<span class="keyword">var</span> EventEmitter = require(<span class="string">'async-cancelable-events'</span>);
<span class="keyword">var</span> util = require(<span class="string">'util'</span>);

<span class="keyword">var</span> nextTick = global.setImmediate ? global.setImmediate : process.nextTick;

<span class="keyword">var</span> q;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Determines if this queue has a name, and either finds or returns said named queue,
or decides it&#39;s an unnamed queue and returns said queue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">qFunc</span><span class="params">(nameOrArray, QType)</span> {</span>
    QType = QType || <span class="keyword">this</span>.q.defaultQ;
    <span class="keyword">if</span>(<span class="keyword">typeof</span>(nameOrArray) === <span class="string">"string"</span>) {
        <span class="keyword">if</span>(!<span class="keyword">this</span>.namedQueues[nameOrArray]) {
            <span class="keyword">this</span>.namedQueues[nameOrArray] = <span class="keyword">new</span> QType(nameOrArray, <span class="keyword">this</span>.q);
        }
        <span class="keyword">return</span> <span class="keyword">this</span>.namedQueues[nameOrArray];
    } <span class="keyword">else</span> <span class="keyword">if</span>(nameOrArray <span class="keyword">instanceof</span> Array) {
        <span class="keyword">return</span> <span class="keyword">new</span> QType(nameOrArray, <span class="keyword">this</span>.q);
    } <span class="keyword">else</span> <span class="keyword">if</span>(nameOrArray <span class="keyword">instanceof</span> Object &amp;&amp;
        <span class="keyword">typeof</span>(nameOrArray.pipe) === <span class="string">'function'</span> &amp;&amp;
        <span class="keyword">typeof</span>(nameOrArray.on) === <span class="string">'function'</span>) {
        <span class="keyword">var</span> newQ = <span class="keyword">new</span> QType(<span class="literal">undefined</span>, <span class="keyword">this</span>.q);
        nameOrArray.on(<span class="string">'data'</span>, newQ.push.bind(newQ));
        nameOrArray.on(<span class="string">'end'</span>, newQ.close.bind(newQ));
        <span class="keyword">return</span> newQ;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">new</span> QType(<span class="literal">undefined</span>, <span class="keyword">this</span>.q);
    }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p><code>exists</code> returns whether or not a named queue exists in</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">exists</span><span class="params">(queueName)</span> {</span>
    <span class="keyword">return</span> !!<span class="keyword">this</span>.namedQueues[queueName] &amp;&amp; <span class="keyword">typeof</span>(<span class="keyword">this</span>.namedQueues[queueName]) === <span class="string">'object'</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p><code>clearQueue</code> removes a queue from a q environment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">clearQueue</span><span class="params">(nameOrQueue)</span> {</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span>(nameOrQueue) === <span class="string">'string'</span>) {
        <span class="keyword">if</span>(<span class="keyword">this</span>.namedQueues[nameOrQueue]) <span class="keyword">delete</span> <span class="keyword">this</span>.namedQueues[nameOrQueue];
    } <span class="keyword">else</span> {
        Object.keys(<span class="keyword">this</span>.namedQueues).forEach(<span class="keyword">function</span>(name) {
            <span class="keyword">if</span>(<span class="keyword">this</span>.namedQueues[name] === nameOrQueue) <span class="keyword">delete</span> <span class="keyword">this</span>.namedQueues[name];
        }.bind(<span class="keyword">this</span>));
    }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p><code>addQueue</code> adds a queue to a q environment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">addQueue</span><span class="params">(name, queue)</span> {</span>
    <span class="keyword">this</span>.namedQueues[name] = queue;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p><code>makeAsync</code> and <code>makeSync</code> helper methods allow a more fluent API to force
async or sync methods, suggested by a colleague, and fits better in the
<code>queue-flow</code> API.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">makeAsync</span><span class="params">(qfMethod)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">function</span>() {
        <span class="keyword">return</span> qfMethod.apply(<span class="keyword">this</span>,
            Array.prototype.slice.call(arguments, <span class="number">0</span>).map(<span class="keyword">function</span>(arg) {
                <span class="keyword">if</span>(arg <span class="keyword">instanceof</span> Function) arg.async = <span class="literal">true</span>;
                <span class="keyword">return</span> arg;
            })
        );
    };
}

<span class="function"><span class="keyword">function</span> <span class="title">makeSync</span><span class="params">(qfMethod)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">function</span>() {
        <span class="keyword">return</span> qfMethod.apply(<span class="keyword">this</span>,
            Array.prototype.slice.call(arguments, <span class="number">0</span>).map(<span class="keyword">function</span>(arg) {
                <span class="keyword">if</span>(arg <span class="keyword">instanceof</span> Function) arg.sync = <span class="literal">true</span>;
                <span class="keyword">return</span> arg;
            })
        );
    };
}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p><code>tuple</code> converts an object into an array of arrays. The arrays are tuples of the
key-value pairs from the object, so they can be processed individually in a queue-flow
if desired, rather than considering the whole object as a single item in the queue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">tuple</span><span class="params">(obj)</span> {</span>
    <span class="keyword">return</span> Object.keys(obj).reduce(<span class="keyword">function</span>(outArr, key) { <span class="keyword">return</span> outArr.concat([[key, obj[key]]]); }, []);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h2>The <code>Q</code> constructor function, which either uses the supplied queueing engine, or</h2>
<p>uses the built-in in-memory engine.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">Q</span><span class="params">(nameOrArray, namespace)</span> {</span>
    EventEmitter.call(<span class="keyword">this</span>);
    <span class="keyword">this</span>.namespace = namespace;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Private variables, the handlers and actual queue array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.wasName = nameOrArray <span class="keyword">instanceof</span> Array ? <span class="literal">false</span> : <span class="literal">true</span>;
    <span class="keyword">var</span> queue = <span class="keyword">this</span>.queue = nameOrArray <span class="keyword">instanceof</span> Array ? nameOrArray : [];
    <span class="keyword">var</span> handler = <span class="keyword">function</span>() {};
    <span class="keyword">var</span> handlerSet = <span class="literal">false</span>;
    <span class="keyword">var</span> handlerBusy = <span class="literal">false</span>;
    <span class="keyword">var</span> recentlyEmptied = <span class="literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Privileged methods</p>
<p><code>setHandler</code> defines the special function to call to process the queue
assumed to be ready initially, when called marked busy, call provided callback to
mark ready again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.setHandler = <span class="function"><span class="keyword">function</span> <span class="title">setHandler</span><span class="params">(handlerFunc)</span> {</span>
        handler = handlerFunc;
        handlerSet = <span class="literal">true</span>;
        <span class="keyword">if</span>(!handlerBusy) handlerCallback(<span class="keyword">function</span>() {});
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }.bind(<span class="keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Eliminate the need for all the binds in the handlerCallback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> handlerEmitter = <span class="keyword">this</span>.emit.bind(<span class="keyword">this</span>);
    <span class="keyword">var</span> handlerRuns = <span class="number">0</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">handlerCall</span><span class="params">()</span> {</span>
        handler(queue.shift(), handlerCallback);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>The <code>handlerCallback</code> is provided to the handler along with the dequeued value.
If there is more work to be done, it continues, otherwise is marks the handler
as ready for when the data next arrives</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> handlerCallback = <span class="function"><span class="keyword">function</span> <span class="title">handlerCallback</span><span class="params">(done)</span> {</span>
        done();
        handlerBusy = <span class="literal">false</span>;
        <span class="keyword">if</span>(queue &amp;&amp; queue.length &gt; <span class="number">0</span>) {
            handlerRuns = handlerRuns % <span class="number">50</span>;
            <span class="keyword">if</span>(handlerRuns) {
                handlerRuns++;
                handlerBusy = <span class="literal">true</span>;
                handlerCall();
            } <span class="keyword">else</span> {
                handlerRuns++;
                handlerBusy = <span class="literal">true</span>;
                nextTick(handlerCall);
            }
        } <span class="keyword">else</span> <span class="keyword">if</span>(!recentlyEmptied) {
            handlerEmitter(<span class="string">'empty'</span>);
            recentlyEmptied = <span class="literal">true</span>;
        }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Inserts a specified value into the queue, if allowed by the event handlers, and
calls the special handler function, if it&#39;s ready.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">()</span> {</span>
        recentlyEmptied = <span class="literal">false</span>;
        <span class="keyword">var</span> values = Array.prototype.slice.call(arguments, <span class="number">0</span>);
        <span class="keyword">this</span>.emitSync(<span class="string">'push'</span>, values);
        Array.prototype.push.apply(queue, values);
        <span class="keyword">if</span>(handlerSet &amp;&amp; !handlerBusy) handlerCallback(<span class="keyword">function</span>() {});
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }.bind(<span class="keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p><code>write</code> is a synonym for <code>push</code> so a queue can be treated as a writeable stream</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.write = <span class="keyword">this</span>.push;</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>For node 0.6 and 0.8 compatibility, listen for the <code>pipe</code> event and register
an event handler to call <code>push</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.on(<span class="string">'pipe'</span>, <span class="keyword">function</span>(piper) {
        piper.on(<span class="string">'data'</span>, <span class="keyword">this</span>.push);
    }.bind(<span class="keyword">this</span>));

    <span class="keyword">this</span>.pushOne = <span class="function"><span class="keyword">function</span> <span class="title">pushOne</span><span class="params">(val)</span> {</span>
        recentlyEmptied = <span class="literal">false</span>;
        <span class="keyword">this</span>.emitSync(<span class="string">'push'</span>, [val]);
        queue.push(val);
        <span class="keyword">if</span>(handlerSet &amp;&amp; !handlerBusy) handlerCallback(<span class="keyword">function</span>() {});
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }.bind(<span class="keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Signals that the queue is being destroyed and then, if allowed, destroys it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.close = <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.emit(<span class="string">'close'</span>, <span class="keyword">function</span>(result) {
            <span class="keyword">if</span>(result) {</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Stop accepting new items so the queue can actually close
if processing time is slower than newly enqueued values come in</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">this</span>.removeAllListeners(<span class="string">'push'</span>);
                <span class="keyword">this</span>.on(<span class="string">'push'</span>, <span class="keyword">function</span>() { <span class="keyword">return</span> <span class="literal">false</span>; });</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Whatever made it into the queue at this point in time, allow it to be
processed and de-queued.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> flushQueue = <span class="keyword">function</span>() {
                    <span class="keyword">var</span> tempHandler = handler;
                    handlerSet = <span class="literal">false</span>;
                    handler = <span class="keyword">function</span>() {};
                    queue = <span class="literal">undefined</span>;
                    <span class="keyword">this</span>.push = <span class="keyword">this</span>.pushOne = <span class="keyword">function</span>() { <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Queue already closed'</span>); };
                    <span class="keyword">if</span>(namespace) namespace.clearQueue(<span class="keyword">this</span>);
                    <span class="keyword">if</span>(tempHandler <span class="keyword">instanceof</span> Function) {
                        tempHandler(<span class="string">'close'</span>);
                    }
                }.bind(<span class="keyword">this</span>);
                <span class="keyword">if</span>(!handlerBusy &amp;&amp; queue &amp;&amp; !queue.length) flushQueue();
                <span class="keyword">if</span>(handlerBusy || (queue &amp;&amp; queue.length)) {
                    <span class="keyword">this</span>.removeAllListeners(<span class="string">'empty'</span>);
                    <span class="keyword">this</span>.on(<span class="string">'empty'</span>, flushQueue);
                }
            }
        }.bind(<span class="keyword">this</span>));
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }.bind(<span class="keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p><code>end</code> is a synonym for <code>close</code> so a queue can be treated as a writeable stream</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.end = <span class="keyword">this</span>.close;</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p> Kills the queue (and all sub-queues) immediately, no possibility of blocking
with an event handler.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.kill = <span class="function"><span class="keyword">function</span> <span class="title">kill</span><span class="params">()</span> {</span>
        <span class="keyword">this</span>.emit(<span class="string">'kill'</span>);
        <span class="keyword">var</span> tempHandler = handler;
        handlerSet = <span class="literal">false</span>;
        handler = <span class="keyword">function</span>() {};
        queue = <span class="literal">undefined</span>;
        <span class="keyword">this</span>.push = <span class="keyword">this</span>.pushOne = <span class="keyword">function</span>() { <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Queue already closed'</span>); };
        <span class="keyword">if</span>(namespace) namespace.clearQueue(<span class="keyword">this</span>);
        <span class="keyword">if</span>(tempHandler <span class="keyword">instanceof</span> Function) {
            tempHandler(<span class="string">'kill'</span>);
        }
    }.bind(<span class="keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Start processing the queue after the next JS event loop cycle and return the queue
object to the remaining code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span>(handlerSet &amp;&amp; !handlerBusy) handlerCallback(<span class="keyword">function</span>() {});
    <span class="keyword">if</span>(queue.length &gt; <span class="number">0</span>) <span class="keyword">this</span>.on(<span class="string">'empty'</span>, <span class="keyword">this</span>.close);
    <span class="keyword">return</span> <span class="keyword">this</span>;
}

util.inherits(Q, EventEmitter);</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h2><code>Q</code> prototype methods, the methods to be most commonly used by users of <code>queue-flow</code></h2>
<p><code>as</code> names or aliases the given queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.as = <span class="function"><span class="keyword">function</span> <span class="title">as</span><span class="params">(name)</span> {</span>
    <span class="keyword">if</span>(<span class="keyword">this</span>.namespace) <span class="keyword">this</span>.namespace.addQueue(name, <span class="keyword">this</span>);
    <span class="keyword">return</span> <span class="keyword">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p><code>concat</code> is a simpler wrapper around <code>push</code> that takes a single array
and covers up the relatively nasty <code>apply</code> mechanism (when dealing with
queue-flow&#39;s particular object model. Getting the <em>queue-flow</em> object
requires <code>q(&#39;nameHere&#39;)</code> and <code>q(&#39;nameHere&#39;).push.apply(q(&#39;nameHere&#39;), array)</code>
is ugly and verbose.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.concat = <span class="function"><span class="keyword">function</span> <span class="title">concat</span><span class="params">(array)</span> {</span>
    <span class="keyword">this</span>.push.apply(<span class="keyword">this</span>, array);
    <span class="keyword">return</span> <span class="keyword">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p><code>each</code> creates an output queue that simply copies the input queue results,
while also passing these results to the provided callback for side-effect
purposes. The output queue is so the data is not destroyed by the <code>each</code>
method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.each = <span class="function"><span class="keyword">function</span> <span class="title">each</span><span class="params">(callback)</span> {</span>
    <span class="keyword">var</span> outQueue = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="literal">null</span>, <span class="keyword">this</span>.namespace);
    <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
        <span class="keyword">if</span>(!next) {
            outQueue[value]();
        } <span class="keyword">else</span> {
            <span class="keyword">if</span>(isAsync(callback, <span class="number">2</span>)) {
                callback(value, <span class="keyword">function</span>() {
                    next(outQueue.push.bind(outQueue, value));
                });
            } <span class="keyword">else</span> {
                callback(value);
                next(outQueue.push.bind(outQueue, value));
            }
        }
    });
    <span class="keyword">return</span> outQueue;
};
Q.prototype.eachAsync = makeAsync(Q.prototype.each);
Q.prototype.eachSync = makeSync(Q.prototype.each);</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p><code>wait</code> is a no-op <code>each</code> that simply delays the queue by a specified amount
or by the amount specified by the callback function (if the argument is a
function instead of a number). This is useful for ratelimiting queues that
otherwise hammer an external service.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.wait = <span class="function"><span class="keyword">function</span> <span class="title">wait</span><span class="params">(delay)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="keyword">function</span>(val, callback) {
        <span class="keyword">if</span>(<span class="keyword">typeof</span>(delay) === <span class="string">'function'</span>) {
            <span class="keyword">if</span>(isAsync(delay, <span class="number">2</span>)) {
                delay(val, <span class="keyword">function</span>(delay) {
                    setTimeout(callback, delay);
                });
            } <span class="keyword">else</span> {
                setTimeout(callback, delay(val));
            }
        } <span class="keyword">else</span> {
            setTimeout(callback, delay);
        }
    });
};
Q.prototype.waitAsync = makeAsync(Q.prototype.wait);
Q.prototype.waitSync = makeSync(Q.prototype.wait);</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p><code>inOut</code> is a helper function used by several of the Q prototype methods that
take an input queue and produce an output queue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> inOut = <span class="function"><span class="keyword">function</span> <span class="title">inOut</span><span class="params">(outQueue, setter, callback)</span> {</span>
    <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
        <span class="keyword">if</span>(!next) {
            outQueue[value]();
        } <span class="keyword">else</span> {
            <span class="keyword">if</span>(isAsync(callback, <span class="number">2</span>)) {
                callback(value, <span class="keyword">function</span>(result) {
                    next(setter.bind(<span class="keyword">this</span>, value, result));
                });
            } <span class="keyword">else</span> {
                next(setter.bind(<span class="keyword">this</span>, value, callback(value)));
            }
        }
    });
    <span class="keyword">return</span> outQueue;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p><code>map</code> creates an output queue, and executes
the given callback on each value, pushing the
result into the output queue before continuing
to process the input queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.map = <span class="function"><span class="keyword">function</span> <span class="title">map</span><span class="params">(callback)</span> {</span>
    <span class="keyword">var</span> outQueue = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="literal">null</span>, <span class="keyword">this</span>.namespace);
    <span class="keyword">if</span>(isAsync(callback, <span class="number">2</span>)) {
        <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
            <span class="keyword">if</span>(!next) {
                outQueue[value]();
            } <span class="keyword">else</span> {
                callback(value, <span class="keyword">function</span>(result) {
                    next(<span class="keyword">function</span>() {
                        outQueue.pushOne(result);
                    });
                });
            }
        });
    } <span class="keyword">else</span> {
        <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
            <span class="keyword">if</span>(!next) {
                outQueue[value]();
            } <span class="keyword">else</span> {
                next(<span class="keyword">function</span>() {
                    outQueue.pushOne(callback(value));
                });
            }
        });
    }
    <span class="keyword">return</span> outQueue;
};
Q.prototype.mapAsync = makeAsync(Q.prototype.map);
Q.prototype.mapSync = makeSync(Q.prototype.map);</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p><code>reduce</code> creates an output variable, and executes once upstream has
<code>close()</code>d, it does one of three things, depending on the value of
<code>last</code>: if undefined it returns an anonymous queue and pushes that
sole result into the queue and closes it immediately. If <code>last</code> is
a string, it pushes that result into the named queue. If <code>last</code> is
a function, it does not create a queue and instead calls <code>last</code> with
the <code>out</code> value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.reduce = <span class="function"><span class="keyword">function</span> <span class="title">reduce</span><span class="params">(callback, last, initial)</span> {</span>
    <span class="keyword">var</span> out = initial;
    <span class="keyword">var</span> outQueue;
    <span class="keyword">if</span>(!last) outQueue = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="literal">null</span>, <span class="keyword">this</span>.namespace);
    <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
        <span class="keyword">if</span>(!next) {
            <span class="keyword">if</span>(!!last &amp;&amp; last <span class="keyword">instanceof</span> Function) last(out);
            <span class="keyword">if</span>(!!last &amp;&amp; <span class="keyword">typeof</span>(last) === <span class="string">'string'</span>) q(last).push(out);
            <span class="keyword">if</span>(!last) {
                outQueue.push(out);
                outQueue[value]();
            }
        } <span class="keyword">else</span> {
            <span class="keyword">if</span>(isAsync(callback, <span class="number">3</span>)) {
                callback(out, value, <span class="keyword">function</span>(result) {
                    next(<span class="keyword">function</span>() {
                        out = result;
                    });
                });
            } <span class="keyword">else</span> {
                next(<span class="keyword">function</span>() {
                    out = callback(out, value);
                });
            }
        }
    }.bind(<span class="keyword">this</span>));
    <span class="keyword">return</span> outQueue || <span class="keyword">this</span>;
};
Q.prototype.reduceAsync = makeAsync(Q.prototype.reduce);
Q.prototype.reduceSync = makeSync(Q.prototype.reduce);</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p><code>filter</code> creates an output queue, and executes
the given callback on each value, pushing the
original value <em>only</em> if the callback returns true.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.filter = <span class="function"><span class="keyword">function</span> <span class="title">filter</span><span class="params">(callback)</span> {</span>
    <span class="keyword">var</span> outQueue = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="literal">null</span>, <span class="keyword">this</span>.namespace);
    <span class="keyword">return</span> inOut.bind(<span class="keyword">this</span>)(outQueue, <span class="function"><span class="keyword">function</span> <span class="title">filterSetter</span><span class="params">(value, result)</span> {</span>
        <span class="keyword">if</span>(result) outQueue.push(value);
    }, callback);
};
Q.prototype.filterAsync = makeAsync(Q.prototype.filter);
Q.prototype.filterSync = makeSync(Q.prototype.filter);</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p><code>branch</code> pushes values from the queue into another queue. If that name
is provided directly to <code>branch</code> it will always push to that named queue.
If a reference to the queue itself is provided branch it will push to that
particular queue. If a function is provided, it will provide it with each
value in the queue and expect to be returned the name, reference, or array
of either to push the value into.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.branch = <span class="function"><span class="keyword">function</span> <span class="title">branch</span><span class="params">(callback)</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
        <span class="function"><span class="keyword">function</span> <span class="title">queueProcessor</span><span class="params">(queue)</span> {</span>
            <span class="keyword">if</span>(<span class="keyword">typeof</span>(queue) === <span class="string">'string'</span>) {
                self.namespace(queue).push(value);
            } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span>(queue) === <span class="string">'object'</span> &amp;&amp; !!queue.push) {
                queue.push(value);
            }
        }
        <span class="keyword">if</span>(!!next) {
            <span class="keyword">if</span>(<span class="keyword">typeof</span>(callback) === <span class="string">'function'</span> &amp;&amp; isAsync(callback, <span class="number">2</span>)) {
                callback(value, <span class="keyword">function</span>(result) {
                    next(<span class="keyword">function</span>() {
                        <span class="keyword">if</span>(result <span class="keyword">instanceof</span> Array) {
                            result.forEach(queueProcessor);
                        } <span class="keyword">else</span> {
                            queueProcessor(result);
                        }
                    });
                });
            } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span>(callback) === <span class="string">'function'</span>) {
                <span class="keyword">var</span> result = callback(value);
                next(<span class="keyword">function</span>() {
                    <span class="keyword">if</span>(result <span class="keyword">instanceof</span> Array) {
                        result.forEach(queueProcessor);
                    } <span class="keyword">else</span> {
                        queueProcessor(result);
                    }
                });
            } <span class="keyword">else</span> <span class="keyword">if</span>(callback <span class="keyword">instanceof</span> Array) {
                next(<span class="keyword">function</span>() {
                    callback.forEach(queueProcessor);
                });
            } <span class="keyword">else</span> {
                next(<span class="keyword">function</span>() {
                    queueProcessor(callback);
                });
            }
        }
    });
    <span class="keyword">return</span> <span class="keyword">this</span>;
};
Q.prototype.branchAsync = makeAsync(Q.prototype.branch);
Q.prototype.branchSync = makeSync(Q.prototype.branch);</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p><code>everySome</code> helper function that is used to implement <code>Q.prototype.every</code>
and <code>Q.prototype.some</code>, similar to <code>reduce</code>, the behavior of <code>everySome</code>
will change whether <code>last</code> is a function, a string, or falsy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> everySome = <span class="function"><span class="keyword">function</span> <span class="title">everySome</span><span class="params">(polarity, callback, last)</span> {</span>
    <span class="keyword">var</span> outQueue;
    <span class="keyword">if</span>(!last) outQueue = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="literal">null</span>, <span class="keyword">this</span>.namespace);
    <span class="function"><span class="keyword">function</span> <span class="title">shortCircuit</span><span class="params">(value, next)</span> {</span> <span class="keyword">if</span>(!!next) next(<span class="keyword">function</span>() {}); }
    <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
        <span class="keyword">if</span>(!next) {
            <span class="keyword">if</span>(!last) {
                outQueue.push(!polarity);
                outQueue.close();
            }
            <span class="keyword">if</span>(!!last &amp;&amp; last <span class="keyword">instanceof</span> Function) last(!polarity); <span class="comment">// Reverse the polarity on the deflector shield!</span>
            <span class="keyword">if</span>(!!last &amp;&amp; <span class="keyword">typeof</span>(last) === <span class="string">'string'</span>) q(last).push(!polarity);
        } <span class="keyword">else</span> {
            <span class="keyword">if</span>(isAsync(callback, <span class="number">2</span>)) {
                callback(value, <span class="keyword">function</span>(result) {
                    next(<span class="keyword">function</span>() {
                        <span class="keyword">if</span>(result === polarity) {
                            <span class="keyword">this</span>.setHandler(shortCircuit);
                            <span class="keyword">if</span>(!last) {
                                outQueue.push(polarity);
                                outQueue.close();
                            }
                            <span class="keyword">if</span>(!!last &amp;&amp; last <span class="keyword">instanceof</span> Function) last(polarity);
                            <span class="keyword">if</span>(!!last &amp;&amp; <span class="keyword">typeof</span>(last) === <span class="string">'string'</span>) q(last).push(polarity);
                        }
                    }.bind(<span class="keyword">this</span>));
                }.bind(<span class="keyword">this</span>));
            } <span class="keyword">else</span> {
                next(<span class="keyword">function</span>() {
                    <span class="keyword">if</span>(callback(value) === polarity) {
                        <span class="keyword">this</span>.setHandler(shortCircuit);
                        <span class="keyword">if</span>(!last) {
                            outQueue.push(polarity);
                            outQueue.close();
                        }
                        <span class="keyword">if</span>(!!last &amp;&amp; last <span class="keyword">instanceof</span> Function) last(polarity);
                        <span class="keyword">if</span>(!!last &amp;&amp; <span class="keyword">typeof</span>(last) === <span class="string">'string'</span>) q(last).push(polarity);
                    }
                }.bind(<span class="keyword">this</span>));
            }
        }
    }.bind(<span class="keyword">this</span>));
    <span class="keyword">return</span> outQueue || <span class="keyword">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p><code>every</code> returns true only if the callback has returned true every time. Immediately returns false
when false and closes the input queue in this event. A specialization of the <code>reduce</code> method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.every = <span class="function"><span class="keyword">function</span> <span class="title">every</span><span class="params">(callback, last)</span> {</span> <span class="keyword">return</span> everySome.bind(<span class="keyword">this</span>, <span class="literal">false</span>, callback, last)(); };
Q.prototype.everyAsync = makeAsync(Q.prototype.every);
Q.prototype.everySync = makeSync(Q.prototype.every);</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p><code>some</code> returns true only if the callback has returned true at least once. Immediately returns true
when true and closes the input queue in this event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.some = <span class="function"><span class="keyword">function</span> <span class="title">some</span><span class="params">(callback, last)</span> {</span> <span class="keyword">return</span> everySome.bind(<span class="keyword">this</span>, <span class="literal">true</span>, callback, last)(); };
Q.prototype.someAsync = makeAsync(Q.prototype.some);
Q.prototype.someSync = makeSync(Q.prototype.some);</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p><code>toArray</code> returns an array from the given queue. A specialization of the <code>reduce</code> method.
Has the same three behaviors depending on the type of value <code>last</code> is, function, string, or
falsy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.toArray = <span class="function"><span class="keyword">function</span> <span class="title">toArray</span><span class="params">(last)</span> {</span>
    <span class="keyword">var</span> outQueue = <span class="keyword">this</span>;
    <span class="keyword">if</span>(!last) {
        outQueue = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="literal">null</span>, <span class="keyword">this</span>.namespace);
        <span class="keyword">this</span>.on(<span class="string">'close'</span>, <span class="keyword">function</span>() { outQueue.push(<span class="keyword">this</span>.queue).close(); }.bind(<span class="keyword">this</span>));
    } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> last === <span class="string">'string'</span>) {
        <span class="keyword">this</span>.on(<span class="string">'close'</span>, <span class="keyword">function</span>() { q(last).push(<span class="keyword">this</span>.queue).close(); }.bind(<span class="keyword">this</span>));
    } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> last === <span class="string">'function'</span>) {
        <span class="keyword">this</span>.on(<span class="string">'close'</span>, last.bind(<span class="keyword">this</span>, <span class="keyword">this</span>.queue));
    }
    <span class="keyword">if</span>(!<span class="keyword">this</span>.wasName) <span class="keyword">this</span>.close();
    <span class="keyword">return</span> outQueue;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p><code>flatten</code> takes an input queue and produces an output queue of values that are not arrays. Any
array encountered is split and enqueued into the new queue recursively, unless given a depth to
flatten to (<code>true</code> == 1 in this case). Intended to be nearly identical to underscore&#39;s <code>flatten</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.flatten = <span class="function"><span class="keyword">function</span> <span class="title">flatten</span><span class="params">(depth)</span> {</span>
    <span class="keyword">var</span> outQueue = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="literal">null</span>, <span class="keyword">this</span>.namespace);
    <span class="function"><span class="keyword">function</span> <span class="title">processValue</span><span class="params">(value, currDepth)</span> {</span>
        <span class="keyword">if</span>(value &amp;&amp; value <span class="keyword">instanceof</span> Array) {
            <span class="keyword">if</span>(depth &amp;&amp; <span class="keyword">typeof</span>(depth) === <span class="string">'number'</span> &amp;&amp; depth === currDepth) {
                outQueue.push(value);
            } <span class="keyword">else</span> {
                value.forEach(<span class="keyword">function</span>(value) { processValue(value, currDepth+<span class="number">1</span>); });
            }
        } <span class="keyword">else</span> {
            outQueue.push(value);
        }
    }

    <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
        <span class="keyword">if</span>(!next) {
            outQueue[value]();
        } <span class="keyword">else</span> {
            next(<span class="keyword">function</span>() {
                processValue(value, <span class="number">0</span>);
            });
        }
    });
    <span class="keyword">return</span> outQueue;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p><code>shortCiruit</code> and <code>ercb</code> are functions common to both the <code>node</code> and <code>exec</code> methods below.
<code>shortCircuit</code> consumes the remaining queue without doing any processing, and <code>ercb</code> is a
callback function with significant error logic, depending on what value is passed into the
<code>onError</code> argument for <code>node</code> and <code>exec</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="comment">/* jshint maxparams: 6 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">ercb</span><span class="params">(outQueue, onError, next, value, error, result)</span> {</span>
    <span class="keyword">if</span>(!error) {
        next(<span class="keyword">function</span>() {
            outQueue.push(result);
        });
    } <span class="keyword">else</span> {
        <span class="keyword">if</span>(!!onError &amp;&amp; onError <span class="keyword">instanceof</span> Function) {
            onError(error, result, value);
        } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span>(onError) === <span class="string">'string'</span>) {
            next(<span class="keyword">function</span>() {
                q(onError).push([error, result, value]);
            });
        } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span>(onError) === <span class="string">'object'</span>) { <span class="comment">// Assume a queue-flow constructed object</span>
            next(<span class="keyword">function</span>() {
                onError.push([error, result, value]);
            });
        }
    }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p><code>node</code> is a slightly modified version of <code>map</code> that takes the input value, and if it is an
array, provides each value as an independent argument to the provided callback. It also assumes
the method returns a correct result and throws an error, or if async calls the callback with two
arguments, considered to be <code>error</code> and <code>value</code>, in that order, which matches most of the
Node.js API callbacks. A second parameter can also be set to determine what <code>node</code> does when
an error is returned. If not set, <code>node</code> simply ignores the error and value and processes the
next item in the queue. If set to <code>true</code>, it kills the queue at this point. If set to a function,
it kills the queue and calls the function with the error and value. If set to a string, it
passes the error and value into a queue of the same name and continues processing the rest of
the queue. If there was an error, for useful debugging the original params passed to exec are
also provided.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.node = <span class="function"><span class="keyword">function</span> <span class="title">node</span><span class="params">(callback, onError)</span> {</span>
    <span class="keyword">var</span> outQueue = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="literal">null</span>, <span class="keyword">this</span>.namespace);
    <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
        <span class="keyword">if</span>(!(value <span class="keyword">instanceof</span> Array)) value = [value];
        <span class="keyword">if</span>(!next) {
            outQueue[value]();
        } <span class="keyword">else</span> {
            <span class="keyword">if</span>(isAsync(callback, value.length+<span class="number">1</span>)) {
                value.push(ercb.bind(<span class="keyword">this</span>, outQueue, onError, next, value));
                callback.apply(<span class="keyword">this</span>, value);
            } <span class="keyword">else</span> {
                <span class="keyword">try</span> {
                    ercb.bind(<span class="keyword">this</span>)(outQueue, onError, next, value, <span class="literal">undefined</span>, callback.apply(<span class="keyword">this</span>, value));
                } <span class="keyword">catch</span>(e) {
                    ercb.bind(<span class="keyword">this</span>)(outQueue, onError, next, value, e);
                }
            }
        }
    }.bind(<span class="keyword">this</span>));
    <span class="keyword">return</span> outQueue;
};
Q.prototype.nodeAsync = makeAsync(Q.prototype.node);
Q.prototype.nodeSync = makeSync(Q.prototype.node);</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p><code>exec</code> assumes the incoming value is a function to execute and takes a couple of arguments.
The first is an array of arguments for the function, or a function that returns an array of
arguments based on the function to be run, while the second is what to do if there is an error,
similar to <code>node</code> above. <code>execCommon</code> is the base for all three versions of <code>exec</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">execCommon</span><span class="params">(forceSyncAsync, args, onError)</span> {</span>
    <span class="keyword">var</span> outQueue = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="literal">null</span>, <span class="keyword">this</span>.namespace);
    <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
        <span class="keyword">if</span>(!next) <span class="keyword">return</span> outQueue[value]();
        <span class="keyword">if</span>(!(value <span class="keyword">instanceof</span> Function)) <span class="keyword">return</span> ercb(outQueue, onError, next, value, <span class="keyword">new</span> Error(<span class="string">'Not a function'</span>), <span class="literal">undefined</span>);
        <span class="function"><span class="keyword">function</span> <span class="title">execFunc</span><span class="params">(args)</span> {</span>
            <span class="keyword">if</span>(forceSyncAsync === <span class="string">'async'</span> || (forceSyncAsync !== <span class="string">'sync'</span> &amp;&amp; isAsync(value, args.length+<span class="number">1</span>))) {
                args.push(ercb.bind(<span class="keyword">this</span>, outQueue, onError, next, value));
                value.apply(<span class="keyword">this</span>, args);
            } <span class="keyword">else</span> {
                <span class="keyword">try</span> {
                    ercb(outQueue, onError, next, value, <span class="literal">undefined</span>, value.apply(<span class="keyword">this</span>, args));
                } <span class="keyword">catch</span>(e) {
                    ercb(outQueue, onError, next, value, e);
                }
            }
        }
        <span class="keyword">if</span>(args <span class="keyword">instanceof</span> Function &amp;&amp; isAsync(args, <span class="number">2</span>)) {
            args(value, <span class="keyword">function</span>() {
                execFunc.bind(<span class="keyword">this</span>)(Array.prototype.slice.call(arguments, <span class="number">0</span>));
            });
        } <span class="keyword">else</span> <span class="keyword">if</span>(args <span class="keyword">instanceof</span> Function) {
            <span class="keyword">try</span> {
                <span class="keyword">var</span> args2 = args(value);
                args2 = args2 <span class="keyword">instanceof</span> Array ? args2 : [args2];
                execFunc.bind(<span class="keyword">this</span>)(args2);
            } <span class="keyword">catch</span>(e) {
                ercb.bind(<span class="keyword">this</span>)(outQueue, onError, next, value, e);
            }
        } <span class="keyword">else</span> <span class="keyword">if</span>(args <span class="keyword">instanceof</span> Array) {
            execFunc.bind(<span class="keyword">this</span>)(args);
        } <span class="keyword">else</span> {
            execFunc.bind(<span class="keyword">this</span>)([args]);
        }
    }.bind(<span class="keyword">this</span>));
    <span class="keyword">return</span> outQueue;
}
Q.prototype.exec = <span class="function"><span class="keyword">function</span> <span class="title">exec</span><span class="params">(args, onError)</span> {</span>
    <span class="keyword">return</span> execCommon.bind(<span class="keyword">this</span>, <span class="literal">false</span>)(args, onError);
};
Q.prototype.execSync = <span class="function"><span class="keyword">function</span> <span class="title">execSync</span><span class="params">(args, onError)</span> {</span>
    <span class="keyword">return</span> execCommon.bind(<span class="keyword">this</span>, <span class="string">'sync'</span>)(args, onError);
};
Q.prototype.execAsync = <span class="function"><span class="keyword">function</span> <span class="title">execAsync</span><span class="params">(args, onError)</span> {</span>
    <span class="keyword">return</span> execCommon.bind(<span class="keyword">this</span>, <span class="string">'async'</span>)(args, onError);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p><code>subqueue</code> allows re-usable queue definitions to be attached to the parent queue. An
anonymous queue is provided to the callback function, and that function must return the
endpoint of the sub-queue that will be continued along in the chain.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.subqueue = <span class="function"><span class="keyword">function</span> <span class="title">subqueue</span><span class="params">(callback)</span> {</span>
    <span class="keyword">if</span>(isAsync(callback, <span class="number">2</span>)) {
        <span class="keyword">var</span> inQueue = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="literal">null</span>, <span class="keyword">this</span>.namespace);
        <span class="keyword">var</span> outQueue = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="literal">null</span>, <span class="keyword">this</span>.namespace);
        <span class="keyword">var</span> buffer = [];
        <span class="keyword">this</span>.each(buffer.push.bind(buffer));
        callback(inQueue, <span class="keyword">function</span>(intermediateQ) {
            inQueue.concat(buffer);
            intermediateQ.branch(outQueue);
        });
        <span class="keyword">return</span> outQueue;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> callback(<span class="keyword">this</span>);
    }
};
Q.prototype.subqueueSync = makeSync(Q.prototype.subqueue);
Q.prototype.subqueueAsync = makeAsync(Q.prototype.subqueue);</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p><code>promise</code> allows the usage of CommonJS Promises in queues. It takes a function that uses
the value or values passed in as the arguments for the construction of the promise, and
then registers handlers for the success and failure scenarios, passing the successes down
and the failures into the specified error queue or callback. Promises are, by definition, async, so
<code>promiseAsync</code> is simply a synonym and <code>promiseSync</code> simply throws an error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.promise = <span class="function"><span class="keyword">function</span> <span class="title">promise</span><span class="params">(callback, error)</span> {</span>
    <span class="keyword">var</span> outQueue = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="literal">null</span>, <span class="keyword">this</span>.namespace);
    <span class="keyword">if</span>(<span class="keyword">typeof</span>(error) === <span class="string">'string'</span>) {
        error = q(error).push.bind(q(error));
    } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span>(error) === <span class="string">'object'</span>) {
        error = error.push.bind(error);
    } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span>(error) !== <span class="string">'function'</span>) {
        error = <span class="keyword">function</span>() {};
    }
    <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
        <span class="keyword">if</span>(!next) <span class="keyword">return</span> outQueue[value]();
        <span class="keyword">if</span>(!(value <span class="keyword">instanceof</span> Array)) value = [value];
        callback.apply(<span class="keyword">this</span>, value).then(<span class="keyword">function</span>(result) {
            next(<span class="keyword">function</span>() {
                outQueue.push(result);
            });
        }, error);
    });
    <span class="keyword">return</span> outQueue;
};
Q.prototype.promiseAsync = Q.prototype.promise;
Q.prototype.promiseSync = <span class="keyword">function</span>() { <span class="keyword">throw</span> <span class="string">"Synchronous Promises are Nonsensical!"</span>; };</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p><code>pipe</code> pushes the queue results into the provided writeable object (and returns it so
if it is also readable, you can continue to <code>pipe</code> it just as you&#39;d expect). Throws
an error if it can&#39;t find the <code>write</code> and <code>end</code> methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.pipe = <span class="function"><span class="keyword">function</span> <span class="title">pipe</span><span class="params">(writable)</span> {</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span>(writable.write) !== <span class="string">'function'</span> || <span class="keyword">typeof</span>(writable.end) !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Not a valid writeable object!'</span>);
    <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
        <span class="keyword">if</span>(!next) <span class="keyword">return</span> writable.end();
        next(<span class="keyword">function</span>() {
            writable.write(value);
        });
    });
    <span class="keyword">return</span> writable;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p><code>drain</code> is a simple callback that empties the attached queue and throws away the
results. This is useful for long-running queues to eliminate references to effectively
&quot;dead&quot; data without using the <code>reduce</code> hack to do so. No chaining is possible
after this call (for obvious reasons).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.prototype.drain = <span class="function"><span class="keyword">function</span> <span class="title">drain</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.setHandler(<span class="keyword">function</span>(value, next) {
        <span class="keyword">if</span>(next &amp;&amp; next <span class="keyword">instanceof</span> Function) next(<span class="keyword">function</span>() {});
    });
    <span class="keyword">return</span> <span class="literal">undefined</span>;
};

<span class="function"><span class="keyword">function</span> <span class="title">ns</span><span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>The q environment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> qEnv = {};

    <span class="keyword">var</span> q = qFunc.bind(qEnv);

    qEnv.q = q;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Hash of named queues</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    qEnv.namedQueues = {};

    q.exists = exists.bind(qEnv);

    q.clearQueue = clearQueue.bind(qEnv);

    q.addQueue = addQueue.bind(qEnv);</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Create a new queue-flow environment/namespace</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    q.ns = ns;</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Expose the <code>Q</code> constructor function (below) so third parties can extend its prototype</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    q.Q = Q;</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Specify the default constructor function for this namespace (may be overridden by user)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    q.defaultQ = Q;</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <h2>Methods of <code>q</code>, mostly helper functions for users of <code>queue-flow</code> and the <code>Q</code> methods</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>    q.makeAsync = makeAsync;
    q.makeSync = makeSync;
    q.tuple = tuple;

    <span class="keyword">return</span> q;
}

q = ns();

module.exports = q;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
