---
layout: site
title: queue-flow
---
<h2>Easy-to-follow data processing with queues, flowcharts, and functional programming</h2>

<p>You know a few programming languages, both static and dynamic, and you've heard good things about Node.js for handling large numbers of standard request-response type connections simultaneously, so you dust off <em>Javascript: The Good Parts</em> and some Node.js tutorials and after a quick refresher you apply your prior experience at this new server-side environment. Just another dynamic server-side language like Ruby, Python, or Perl, right?</p>

<p>But soon, you find your code has become difficult to read and refactor as you are</p>

<pre><code>lost(arg, function(err, result) {
    if(err) return console.log(err);
    in(result, function(err, result) {
        if(err) return console.log(err);
        callback(result, function(err, result) {
            if(err) return console.log(err);
            hell(result);
        });
    });
});
</code></pre>

<p>("lost in callback hell", by the way). You just want to accomplish what the outermost function wants to do, so you specify closure callbacks within it with the code that's specific to this function. But there's so much boilerplate and indentation! And because they are closures, you just use the outer scope variables at will, which means later on when you decide that the two innermost functions would be useful elsewhere, you can't actually just define it as an independent function without significantly refactoring your code, and since the callbacks are required to have a fixed set of input arguments, how would you pass the needed variables in, anyways? (Hint: <code>Function.prototype.bind</code>, but it's still painful.) So you just copy-paste the block over and mangle it manually.</p>

<p>So, you start looking for solutions. <code>Fibers</code> looks very promising, but you quickly realize that any code you write on top of it, and any library that you depend on that uses it, cannot be used in the browser, and cannot even be used in Node.js for Windows, and come to understand why so little of the Node.js community relies on Fibers. So, believing that a quality solution can't be done in the Javascript syntax proper, you decide to take a look at a popular solution, and the most popular by far is Async.</p>

<p>Following the wisdom of the crowd, you start to refactor your code using the async library, and it does help some, but is this any better than what we had before?</p>

<pre><code>async.waterfall([
    function(next) {
        lost(arg, next);
    },
    function(result, next) {
        in(result, next);
    },
    function(result, next) {
        callback(result, next);
    }
], function(err, result) {
    if(err) return console.log(err);
    hell(result);
});
</code></pre>

<p>We've now made the same task take more lines of code, and we still have two indent levels, removing only one from the previous situation, and reusing these functions is still difficult, as each async method "verb" must be called within the callback used by the prior method's callback (perhaps the entire <code>async.waterfall</code> call is inside of the callback for an <code>async.reduce</code>). It has saved <em>some</em> boilerplate, but it doesn't feel like much.</p>

<p>(To be fair to <code>async</code>, the above code could be reduced in size, but that's only because the steps are simple single-function-call steps. Any time more than two statements are involved, like the final callback, you need to define a closure to handle it, as all of the callbacks within the array (true of all of the flow-control methods of async) must have the same kind of behavior.)</p>

<p>To be honest, the ECMAScript 5 standard of Javascript has some nice functional programming concepts added to the <code>Array</code> object. <code>map, reduce, filter, forEach</code>, etc. You could write generic functions that manipulated data in certain ways, and then combine them in whatever order you desired to process chunks of data. Then when it's done, you decide perhaps classify it based on the result and then feed it to one of a few functions specialized for that kind of data and continue the processing until you're ready to return something to the user.</p>

<p>But there are a few things stopping that in Node.js or even AJAX-heavy browser development:</p>

<ol>
<li>This is a blocking API, so no AJAX allowed, no Node.js libraries allowed.</li>
<li>Each step in the process will only start its work <em>after</em> the previous step has completed <em>all</em> of the work it has to do, meaning significant latency, especially when the processing time of the callback is unpredictable like in I/O calls.</li>
<li>The "branching" logic between these bits of processing is still imperative, so it may have the same tendency to be copy-pasted, but this is the least important of worries.</li>
</ol>

<h2>Enter <em>queue-flow</em></h2>

<p><code>queue-flow</code> promises to solve these problems, presenting an async-capable (but not required) API similar to ECMAScript 5 or underscore.js, while introducing a few core concepts to give you much expresive power, all built within the standard Javascript syntax so it will work in whatever JS environment you place it in.</p>

<p>The core concepts are these: you define queues that data is put into and processed according to a series of steps. These queues can be named so you can specifically refer to them from functions or other queues. The standard <code>each, map, reduce, filter</code>, etc method "verbs" are defined, along with an <code>exec</code> verb specifically designed to easily work with Node.js-style APIs, and a <code>branch</code> verb for deciding which queue a given piece of data should continue on. The <code>branch</code> verb is the final concept: if you think of each step in the queue as a processing box in a flowchart, <code>branch</code> is your decision box, making it possible for conditional behavior and loops to be defined with your queues.</p>

<p>Now the <em>flow</em> of your data through your <em>queues</em> can be defined at a high level, while your lower-level decisions are handled within your functions, which can be kept general purpose and reusable between many queues. It can be a mix of sync and async code, they can be reordered with a simple select-click-and-drag because they're all at the same indent level. Linear steps are kept perfectly linear, functions are kept easily reusable. Developers are kept sane.</p>

<h2>License (MIT)</h2>

<p>Copyright (C) 2012 by David Ellis</p>

<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.</p>